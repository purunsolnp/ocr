<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Overlay</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: transparent;
    }

    #overlay-text {
      position: absolute;
      left: 10px;
      top: 10px;
      font-size: 32px;
      font-family: 'Segoe UI', sans-serif;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 12px 24px;
      border-radius: 12px;
      max-width: 90vw;
      white-space: pre-wrap;
      pointer-events: none;
      user-select: none;
      transition: opacity 0.3s ease, visibility 0.3s;
    }
    
    #overlay-text.transparent {
      opacity: 0;
      visibility: hidden;
    }
    
    #size-info {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 12px;
      border-radius: 3px;
      z-index: 1000;
      transition: opacity 1s ease;
    }
    
    #connection-status {
      position: absolute;
      bottom: 5px;
      right: 5px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
      z-index: 1000;
    }

    #debug-panel {
      position: absolute;
      bottom: 25px;
      right: 5px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 3px;
      font-size: 10px;
      z-index: 1000;
      max-width: 300px;
      display: none;
    }
  </style>
</head>
<body>
  <!-- ë¸Œë¼ìš°ì € í¬ê¸° ì •ë³´ í‘œì‹œ (OBS ì„¤ì • ìš©) -->
  <div id="size-info">ê¶Œì¥ í¬ê¸° ê³„ì‚° ì¤‘...</div>
  
  <!-- ì—°ê²° ìƒíƒœ í‘œì‹œ (ë””ë²„ê¹…ìš©) -->
  <div id="connection-status">ì—°ê²° ìƒíƒœ: ëŒ€ê¸° ì¤‘...</div>
  
  <!-- ë²ˆì—­ í…ìŠ¤íŠ¸ í‘œì‹œ ì˜ì—­ -->
  <div id="overlay-text">ë¡œë”© ì¤‘...</div>

  <!-- ë””ë²„ê·¸ íŒ¨ë„ (í•„ìš”ì‹œ í‘œì‹œ) -->
  <div id="debug-panel"></div>

  <!-- socket.io ì—°ê²° -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    // ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì • (ë¬¸ì œ í•´ê²° í›„ falseë¡œ ë³€ê²½)
    const DEBUG_MODE = true;
    
    // ì£¼ìš” DOM ìš”ì†Œ
    const overlay = document.getElementById("overlay-text");
    const sizeInfo = document.getElementById("size-info");
    const connectionStatus = document.getElementById("connection-status");
    const debugPanel = document.getElementById("debug-panel");
    
    // ë””ë²„ê·¸ ëª¨ë“œì¼ ë•Œë§Œ ë””ë²„ê·¸ íŒ¨ë„ í‘œì‹œ
    if (DEBUG_MODE) {
      debugPanel.style.display = "block";
    }
    
    // ë””ë²„ê·¸ ë¡œê·¸ í•¨ìˆ˜
    function debugLog(message) {
      if (DEBUG_MODE) {
        console.log(message);
        // ë””ë²„ê·¸ íŒ¨ë„ì—ë„ í‘œì‹œ (ìµœì‹  5ê°œ ë©”ì‹œì§€ë§Œ)
        const lines = debugPanel.innerHTML.split('<br>');
        if (lines.length > 5) {
          lines.pop();
        }
        debugPanel.innerHTML = message + '<br>' + lines.join('<br>');
      }
    }
    
    // ì˜¤ë²„ë ˆì´ ìƒíƒœ ë””ë²„ê¹… í•¨ìˆ˜
    function logOverlayState() {
      if (DEBUG_MODE) {
        const isTransparent = overlay.classList.contains('transparent');
        const computedStyle = window.getComputedStyle(overlay);
        debugLog(`[ì˜¤ë²„ë ˆì´ ìƒíƒœ] íˆ¬ëª…: ${isTransparent}, ë¶ˆíˆ¬ëª…ë„: ${computedStyle.opacity}, ê°€ì‹œì„±: ${computedStyle.visibility}, ë‚´ìš©: ${overlay.textContent.length > 0 ? 'ìˆìŒ' : 'ì—†ìŒ'}`);
      }
    }
    
    // ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
    fetch("/get_overlay_settings")
      .then(res => res.json())
      .then(settings => {
        // í°íŠ¸ ë° ìŠ¤íƒ€ì¼ ì ìš©
        if (settings.fontFamily) {
          overlay.style.fontFamily = `'${settings.fontFamily}', 'Segoe UI', sans-serif`;
        }
        
        if (settings.fontSize) {
          overlay.style.fontSize = `${settings.fontSize}px`;
        }
        
        if (settings.fontColor) {
          overlay.style.color = settings.fontColor;
        }
        
        if (settings.backgroundColor) {
          overlay.style.backgroundColor = settings.backgroundColor;
        }
        
        debugLog("[âš™ï¸ ì˜¤ë²„ë ˆì´ ì„¤ì • ì ìš©ë¨]");
        connectionStatus.textContent = `ì„¤ì • ë¡œë“œë¨`;
      })
      .catch(error => {
        console.error("[âš ï¸ ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜]", error);
        connectionStatus.textContent = `ì„¤ì • ì˜¤ë¥˜: ${error.message}`;
      });

    // overlay ìœ„ì¹˜ ì„¤ì • (ê³ ì • ìœ„ì¹˜ ì‚¬ìš©)
    overlay.style.left = '10px';
    overlay.style.top = '10px';
      
    // ê¶Œì¥ í¬ê¸° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    fetch('/get_browser_size')
      .then(response => response.json())
      .then(data => {
        // í¬ê¸° ì •ë³´ ê³„ì‚°
        const ocr_width = data.width;
        const ocr_height = data.height;
        const recommended_height = data.recommended_height || Math.max(120, Math.floor(ocr_height * 0.4));
        
        // ê¶Œì¥ í¬ê¸° ë©”ì‹œì§€ í‘œì‹œ (ëŒ€ì‚¬ì°½ ìŠ¤íƒ€ì¼)
        sizeInfo.innerHTML = `
          <strong>OBS ë¸Œë¼ìš°ì € ì†ŒìŠ¤ ì„¤ì • ì•ˆë‚´</strong><br>
          <strong>OCR ì˜ì—­ í¬ê¸°:</strong> ${ocr_width} Ã— ${ocr_height}px<br>
          <strong>ê¶Œì¥ ë¸Œë¼ìš°ì € í¬ê¸°:</strong> ${ocr_width} Ã— ${recommended_height}px<br>
          <strong>CSS:</strong> overflow: visible
        `;
        
        // 15ì´ˆ í›„ í¬ê¸° ì •ë³´ ìˆ¨ê¸°ê¸°
        setTimeout(() => {
          sizeInfo.style.opacity = '0';
          setTimeout(() => {
            sizeInfo.style.display = 'none';
          }, 1000);
        }, 15000);
      })
      .catch(error => {
        console.error('í¬ê¸° ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
        sizeInfo.textContent = 'í¬ê¸° ì •ë³´ ì˜¤ë¥˜: ' + error.message;
      });

    // ì—°ê²° ìƒíƒœ ê´€ë¦¬ ë³€ìˆ˜
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    
    // ì—°ê²° í…ŒìŠ¤íŠ¸
    function checkSocket() {
      if (socket.connected) {
        connectionStatus.textContent = 'ì—°ê²° ìƒíƒœ: ì—°ê²°ë¨';
        connectionStatus.style.backgroundColor = 'rgba(0, 128, 0, 0.7)';
        reconnectAttempts = 0; // ì—°ê²° ì„±ê³µ ì‹œ ì‹œë„ ì¹´ìš´í„° ì´ˆê¸°í™”
      } else {
        connectionStatus.textContent = `ì—°ê²° ìƒíƒœ: ëŠê¹€ (ì¬ì‹œë„: ${reconnectAttempts+1}/${MAX_RECONNECT_ATTEMPTS})`;
        connectionStatus.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        
        // ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ë‚´ì¼ ë•Œë§Œ ì¬ì—°ê²° ì‹œë„
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          debugLog(`[ğŸ”„ ì¬ì—°ê²° ì‹œë„] ${reconnectAttempts+1}/${MAX_RECONNECT_ATTEMPTS}`);
          socket.connect();
          reconnectAttempts++;
        } else {
          debugLog("[âš ï¸ ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼]");
          connectionStatus.textContent = `ì—°ê²° ìƒíƒœ: ì‹¤íŒ¨ (ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼)`;
        }
      }
    }
    
    // íˆ¬ëª… ëª¨ë“œ ì„¤ì • í•¨ìˆ˜ (ì´ë²¤íŠ¸ ì²˜ë¦¬ í†µí•©)
    function setTransparentMode(transparent = true) {
      // ê¸°ì¡´ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë¨¸ ì œê±°
      if (window.transparencyTimer) {
        clearTimeout(window.transparencyTimer);
      }
      
      if (transparent) {
        debugLog("[ğŸ” íˆ¬ëª… ëª¨ë“œë¡œ ì „í™˜]");
        overlay.classList.add('transparent');
        
        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í…ìŠ¤íŠ¸ ì œê±° (ê°€ì‹œì„± ë³€ê²½ ì• ë‹ˆë©”ì´ì…˜ê³¼ ë™ê¸°í™”)
        window.transparencyTimer = setTimeout(() => {
          overlay.textContent = '';
          logOverlayState();
        }, 300); // CSS transitionê³¼ ë™ì¼í•œ ì‹œê°„
      } else {
        overlay.classList.remove('transparent');
        debugLog("[ğŸ” ì¼ë°˜ ëª¨ë“œë¡œ ì „í™˜]");
        logOverlayState();
      }
    }
    
    // WebSocket ì—°ê²°
    const socket = io();

    socket.on("connect", () => {
      debugLog("ğŸ”Œ WebSocket ì—°ê²°ë¨");
      connectionStatus.textContent = 'ì—°ê²° ìƒíƒœ: ì—°ê²°ë¨';
      connectionStatus.style.backgroundColor = 'rgba(0, 128, 0, 0.7)';
      
      // ìˆ˜ë™ìœ¼ë¡œ í…ìŠ¤íŠ¸ ìš”ì²­
      socket.emit('get_latest_text');
      
      // í˜„ì¬ ì˜¤ë²„ë ˆì´ ìƒíƒœ ë¡œê¹…
      logOverlayState();
    });

    // ì˜¤ë²„ë ˆì´ ëª¨ë“œ ë³€ê²½ ì´ë²¤íŠ¸ ì²˜ë¦¬ (íˆ¬ëª…/ì¼ë°˜)
    socket.on("set_overlay_mode", (mode) => {
      debugLog("[ğŸ” ì˜¤ë²„ë ˆì´ ëª¨ë“œ ë³€ê²½]:" + mode);
      
      if (mode === 'transparent') {
        setTransparentMode(true);
      } else {
        setTransparentMode(false);
      }
    });

    // í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    socket.on("overlay_text", (text) => {
      debugLog("[ğŸ“¥ í…ìŠ¤íŠ¸ ìˆ˜ì‹ ]: " + (text.length > 20 ? text.substring(0, 20) + "..." : text));
      
      // ê¸°ë³¸ í…ìŠ¤íŠ¸("ë²ˆì—­ ì—†ìŒ") ì²˜ë¦¬
      if (text === "(ë²ˆì—­ ì—†ìŒ)") {
        debugLog("[ğŸ” ê¸°ë³¸ í…ìŠ¤íŠ¸ ê°ì§€ë¨ - íˆ¬ëª… ëª¨ë“œë¡œ ì „í™˜]");
        setTransparentMode(true);
      } else {
        // ì¼ë°˜ í…ìŠ¤íŠ¸ ì²˜ë¦¬
        setTransparentMode(false);
        overlay.textContent = text;
      }
      
      // ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
      connectionStatus.textContent = `ì—°ê²°ë¨ - í…ìŠ¤íŠ¸ ìˆ˜ì‹ : ${new Date().toLocaleTimeString()}`;
      
      // í˜„ì¬ ì˜¤ë²„ë ˆì´ ìƒíƒœ ë¡œê¹…
      logOverlayState();
    });

    socket.on("disconnect", () => {
      debugLog("ğŸ”Œ WebSocket ì—°ê²° ëŠê¹€");
      connectionStatus.textContent = 'ì—°ê²° ìƒíƒœ: ëŠê¹€';
      connectionStatus.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
    });

    socket.on("connect_error", (error) => {
      debugLog("ğŸš« WebSocket ì—°ê²° ì˜¤ë¥˜: " + error.message);
      connectionStatus.textContent = `ì—°ê²° ì˜¤ë¥˜: ${error.message}`;
      connectionStatus.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
    });
    
    // ì´ˆê¸° ìƒíƒœ ì„¤ì • (ë¡œë”© ì¤‘ í…ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°)
    setTimeout(() => {
      setTransparentMode(true);
    }, 1000);
    
    // ì£¼ê¸°ì ìœ¼ë¡œ ì—°ê²° ìƒíƒœ í™•ì¸ (3ì´ˆë§ˆë‹¤)
    setInterval(checkSocket, 3000);
    
    // 5ì´ˆë§ˆë‹¤ ìµœì‹  í…ìŠ¤íŠ¸ ìš”ì²­ (ì—°ê²° ìœ ì§€ ë° ìƒíƒœ ë™ê¸°í™”)
    setInterval(() => {
      if (socket.connected) {
        socket.emit('get_latest_text');
      }
    }, 5000);
    
    // ë””ë²„ê·¸ ëª¨ë“œì—ì„œ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì¶”ê°€
    if (DEBUG_MODE) {
      // 'D' í‚¤ë¥¼ ëˆ„ë¥´ë©´ í˜„ì¬ ì˜¤ë²„ë ˆì´ ìƒíƒœ ì¶œë ¥
      document.addEventListener('keydown', (e) => {
        if (e.key === 'd' || e.key === 'D') {
          logOverlayState();
        }
      });
    }
  </script>
</body>
</html>